import {Middleware, Request} from '@loopback/rest';
import {AppAccessTokenRepository} from './../../repositories';
import {RandomizationUtils, LoggingUtils, RestError} from './../../utils';
// import { InfoSpecEnhancer } from 'common/src/middlewares/openapiSpecEnhancer';
import {AppAccessToken} from '../../models';
import {RoleResolver} from './role-resolver';

const fs = require('fs');
const os = require('os');

export const authenticateRequest: Middleware = async function (this: any, requestContext, next) {
  const userProfile: any = {resolvedRoles: ['$everyone']};
  var {request, response} = requestContext;
  const headers: any = request.headers;

  const API_KEY = process.env.COMMON_API_KEY;

  //Throw error if no API key set
  if (!API_KEY) {
    throw Error('API KEY not present');
  }

  if (!('trxid' in request.headers)) {
    var trxId = createTransactionId();
    request.headers['TrxId'] = trxId;
  }
  //If Transaction Id is available, use the existing one
  else {
    var trxId: string = headers['trxid'];
  }
  let additionalHeaders: any = {
    headers: {
      Authorization: API_KEY,
      TrxId: trxId,
      source: 'external-system'
    }
  };

  userProfile['TrxId'] = trxId;
  userProfile['ip'] = headers['x-forwarded-for'] ?? request.ip;
  //If request coming from external system
  var authorizationToken = '';
  var tokenData: any = {};

  //check if request is from one of the other microservices
  if (
    ('Authorization' in headers || 'authorization' in headers) &&
    'trxid' in headers &&
    'source' in headers &&
    headers.source === 'external-system' &&
    (headers['Authorization'] === API_KEY || headers['authorization'] === API_KEY)
  ) {
    // additionalHeaders.headers.TrxId = headers.TrxId
    userProfile.resolvedRoles = ['external-system'];
  } else {
    if (!('Authorization' in headers || 'authorization' in headers)) {
      userProfile.resolvedRoles.push('$unAuthenticated');
    } else {
      //check if the auth Token is valid
      const appAccessTokenRepository = await this.getRepository(AppAccessTokenRepository);
      authorizationToken = headers['Authorization'] || headers['authorization'];
      let foundUser: AppAccessToken | null = await appAccessTokenRepository
        .findOne(
          {
            where: {
              token: authorizationToken
            }
          },
          additionalHeaders
        )
        .catch(async (err: any) => {
          LoggingUtils.error(err);
          // throw err;
          //setting HSTS header beforte ending request
          response.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
          response.status(401).send('Something went wrong!');
        });
      if (foundUser && foundUser.expiry) {
        const curreDate = new Date();
        const accessTokenExpiryDate = new Date(foundUser!.expiry);

        //if the isActive Column is false it means that another user has logged in. This is later checked in the authorization middleware
        if (foundUser.isActive === false) {
          foundUser = null;
          userProfile['anotherUserLoggedIn'] = true;
        }
        //if the token has expired. This is later checked in the authorization middleware
        else if (curreDate > accessTokenExpiryDate) {
          foundUser = null;
          userProfile['isExpired'] = true;
        }
      }
      //If invalid, add $unAuthenticatd
      if (!foundUser || !foundUser.tokenData) userProfile.resolvedRoles.push('$unAuthenticated');
      else {
        tokenData = foundUser?.tokenData ?? {};
        if (!tokenData.appRoles) tokenData.appRoles = []; //Adding this as some existing tokenData doesn't have appRoles
        userProfile.resolvedRoles = [...userProfile.resolvedRoles, ...tokenData.appRoles];
        userProfile.resolvedRoles.push('$authenticated');
        if (!tokenData.accessibleAppUserIds) tokenData['accessibleAppUserIds'] = [tokenData.appUserId];

        const roleResolver = new RoleResolver(request, tokenData);
        const resolvedRolesFromRoleResolver = roleResolver.resolveRoles();

        //If the token is generated by verifyotp and the resolved role includes $owner, then we attach the $otpVerified role
        if (tokenData.appRoles.includes('$otpVerified')) {
          if (!resolvedRolesFromRoleResolver.includes('$owner')) {
            userProfile.resolvedRoles = userProfile.resolvedRoles.filter((role: string) => role !== '$otpVerified'); // remove the $otpVerified role in case $owner wasn't established for the user
          }
        } else {
          userProfile.resolvedRoles = [...userProfile.resolvedRoles, ...resolvedRolesFromRoleResolver];
        }
      }
    }
  }
  const userProfileData = {...tokenData, ...userProfile};
  const auditLogParams = createAuditLogParams(additionalHeaders, userProfileData, request);
  additionalHeaders = {...additionalHeaders, logParams: auditLogParams};
  requestContext.bind('userProfile').to(userProfileData);
  requestContext.bind('additionalHeaders').to(additionalHeaders);
  const result = await next();
  return result;
};

const createTransactionId = () => {
  return Date.now() + RandomizationUtils.generateUniqueId(16);
};

const createAuditLogParams = (additionalHeaders: any, userProfile: any, request: Request) => {
  const optionsForAuditing = {
    doAuditLog: false, //@todo need to decide based on roles
    transactionId: additionalHeaders.headers.TrxId,
    ipAddress: request.headers['x-forwarded-for'] ?? request.ip,
    hostName: request.hostname,
    source: 'unknown', //@todo need to identify if we're fetching source from headers
    version: 'unknown', //@todo need to identify if we're fetching app/webapp version from headers
    appUserId: userProfile.appUserId,
    url: request.originalUrl,
    query: request.query
  };
  if (request.headers.source) optionsForAuditing.source = request.headers.source as string;
  if (request.headers.version) optionsForAuditing.version = request.headers.version as string;
  if (userProfile.appRoleIds && userProfile.appRoleIds.some((id: number) => id > 1)) optionsForAuditing.doAuditLog = true; // As audit log is only for Operations users
  return optionsForAuditing;
};
